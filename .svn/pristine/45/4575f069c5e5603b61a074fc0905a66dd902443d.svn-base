#include "accelerometer.h"
#include "DMA.h"
#include "i2c_init.h"
#include "leds.h"
#include <gpio.h>
#include <stdint.h>
#include <stm32.h>

#define CTRL_REG1 0x20
#define CTRL_REG3 0x22

#define OUT_X 0x29
#define OUT_Y 0x2B
#define OUT_Z 0x2D

#define SCL_GPIO GPIOB
#define SCL_LINE 8
#define SDA_GPIO GPIOB
#define SDA_LINE 9

#define INT1 PA1
#define INT2 PA8

#define PCLK1_HZ 16000000

#define X_LED RED
#define Y_LED GREEN
#define Z_LED BLUE

#define LIS35DE_ADDR 0x1C
#define CTRL_REG1_INIT_VALUE (1 << 6) | (1 << 2) | (1 << 1) | (1 << 0)
#define CTRL_REG3_INIT_VALUE 0

typedef int8_t reg_t;
typedef int8_t reg_val_t;
typedef void (*i2c_write_callback)();
typedef void (*i2c_read_callback)(reg_val_t val);

typedef struct {
    enum i2c_mode_enum { READ, WRITE } mode;
    reg_t reg;
    reg_val_t value;
    union {
        i2c_write_callback write;
        i2c_read_callback read;
    } callback;
} i2c_data_t;

i2c_data_t i2c_data;


static void init_leds() {
    leds_setup();
    Green2LEDon();
}

static void configure_gpio() {
    GPIOafConfigure(SCL_GPIO, SCL_LINE, GPIO_OType_OD, GPIO_Low_Speed, GPIO_PuPd_NOPULL,
                    GPIO_AF_I2C1);
    GPIOafConfigure(SDA_GPIO, SDA_LINE, GPIO_OType_OD, GPIO_Low_Speed, GPIO_PuPd_NOPULL,
                    GPIO_AF_I2C1);
}

void write_buf() {
    while (!(USART2->SR & USART_SR_TXE)) {
    }
    USART_write_from_buffer();
}

void dupa_debug(char *dupa) {
    USART_add_string_to_out_buffer(dupa);
    write_buf();
    write_buf();
    write_buf();
    write_buf();
    write_buf();
}

void i2c_write(reg_t reg, reg_val_t value, i2c_write_callback callback);
void i2c_read(reg_t reg, i2c_read_callback callback);

static float float_abs(float f) {
    if (f < 0) {
        return -f;
    }
    return f;
}

static float normalize(float f) {
    return 1 - float_abs(f / 128);
}

void read_x(reg_val_t z);

void read_z(reg_val_t y) {
    leds_change_green_intensity(normalize(y));

    USART_add_char_to_out_buffer(y);
    write_buf();
    i2c_read(OUT_Z, &read_x);
}

void read_y(reg_val_t x) {
    leds_change_red_intensity(normalize(x));
    USART_add_char_to_out_buffer(x);
    write_buf();
    i2c_read(OUT_Y, &read_z);
}

void read_x(reg_val_t z) {
    leds_change_blue_intensity(normalize(z));
    i2c_read(OUT_X, &read_y);
}

void read_values() {
    read_x(1);
}

void set_reg3_config() {
    i2c_write(CTRL_REG3, CTRL_REG3_INIT_VALUE, &read_values);
}

void set_reg1_config() {
    i2c_write(CTRL_REG1, CTRL_REG1_INIT_VALUE, &set_reg3_config);
}

void zero_reg3() {
    i2c_write(CTRL_REG3, 0, &set_reg1_config);
}

void handle_unmatched_sr1_reg(uint16_t sr1) {
    for (int i = 0; i < 16; i++) {
        USART_add_char_to_out_buffer(sr1 % 2 + '0');
        write_buf();
        sr1 /= 2;
    }
}

void I2C1_EV_IRQHandler_read() {
    enum next { SB, ADDR, BTF, SB2, ADDR2, RXNE };
    static enum next next_state = SB;

    dupa_debug("RPrz\n");
    uint16_t sr1 = I2C1->SR1;
    if (next_state == SB && (sr1 & I2C_SR1_SB)) {
        dupa_debug("ReSB\n");
        I2C1->DR = LIS35DE_ADDR << 1;
        next_state = ADDR;
    } else if (next_state == ADDR && (sr1 & I2C_SR1_ADDR)) {
        dupa_debug("RADR\n");

        next_state = BTF;
        I2C1->SR2;
        I2C1->DR = i2c_data.reg;
    } else if (next_state == BTF && (sr1 & I2C_SR1_BTF)) {
        dupa_debug("RBTF\n");
        I2C1->CR1 |= I2C_CR1_START;
        next_state = SB2;
    } else if (next_state == SB2 && (sr1 & I2C_SR1_SB)) {
        dupa_debug("RSB2\n");
        I2C1->DR = LIS35DE_ADDR << 1 | 1;

        I2C1->CR1 &= ~I2C_CR1_ACK;
        next_state = ADDR2;
    } else if (next_state == ADDR2 && (sr1 & I2C_SR1_ADDR)) {
        dupa_debug("RAD2\n");
        I2C1->SR2;

        I2C1->CR1 |= I2C_CR1_STOP;
        I2C1->CR2 ^= I2C_CR2_ITBUFEN;
        next_state = RXNE;
    } else if (next_state == RXNE && (sr1 & I2C_SR1_RXNE)) {
        dupa_debug("RXNE\n");

        next_state = SB;
        if (i2c_data.callback.read != NULL) {
            i2c_data.callback.read(I2C1->DR);
        }
    } else {
        handle_unmatched_sr1_reg(sr1);
    }
}

void I2C1_EV_IRQHandler_write() {
    enum next { SB, ADDR, TX, BTF };
    static enum next next_state = SB;

    dupa_debug("PRZE\n");
    uint16_t sr1 = I2C1->SR1;
    if (next_state == SB && (sr1 & I2C_SR1_SB)) {
        dupa_debug("SB\n");
        I2C1->DR = LIS35DE_ADDR << 1;
        next_state = ADDR;
    } else if (next_state == ADDR && (sr1 & I2C_SR1_ADDR)) {
        dupa_debug("ADDR\n");
        I2C1->SR2;
        I2C1->DR = i2c_data.reg;
        next_state = TX;
    } else if (next_state == TX && (sr1 & I2C_SR1_TXE)) {
        dupa_debug("TXE\n");
        I2C1->DR = i2c_data.value;
        next_state = BTF;
    } else if (next_state == BTF && (sr1 & I2C_SR1_BTF)) {
        dupa_debug("BTF\n");
        I2C1->CR1 |= I2C_CR1_STOP;
        I2C1->CR2 ^= I2C_CR2_ITBUFEN;
        next_state = SB;
        if (i2c_data.callback.write != NULL) {
            i2c_data.callback.write();
        }
    } else {
        handle_unmatched_sr1_reg(sr1);
    }
}

void I2C1_EV_IRQHandler() {
    Green2LEDoff();
    if (i2c_data.mode == READ) {
        I2C1_EV_IRQHandler_read();
    } else {
        I2C1_EV_IRQHandler_write();
    }
    Green2LEDon();
}

void i2c_write(reg_t reg, reg_val_t value, i2c_write_callback callback) {
    i2c_data.mode = WRITE;
    i2c_data.reg = reg;
    i2c_data.value = value;
    i2c_data.callback.write = callback;

    I2C1->CR2 |= I2C_CR2_ITBUFEN;
    I2C1->CR1 |= I2C_CR1_START;
}

void i2c_read(reg_t reg, i2c_read_callback callback) {
    i2c_data.mode = READ;
    i2c_data.reg = reg;
    i2c_data.callback.read = callback;

    I2C1->CR2 |= I2C_CR2_ITBUFEN;
    I2C1->CR1 |= I2C_CR1_START;
}

static char *_float_to_char(float x, char *p) {
    char *s = p + 10;  // go to end of buffer
    uint16_t decimals; // variable to store the decimals
    int units;         // variable to store the units (part to left of decimal place)
    if (x < 0) {       // take care of negative numbers
        decimals = (int)(x * -100) % 100; // make 1000 for 3 decimals etc.
        units = (int)(-1 * x);
    } else { // positive numbers
        decimals = (int)(x * 100) % 100;
        units = (int)x;
    }

    *--s = (decimals % 10) + '0';
    decimals /= 10; // repeat for as many decimal places as you need
    *--s = (decimals % 10) + '0';
    *--s = '.';

    while (units > 0) {
        *--s = (units % 10) + '0';
        units /= 10;
    }
    if (x < 0)
        *--s = '-'; // unary minus sign for negative numbers
    return s;
}

static void write_new_values(int x, int y, int z) {
    char buff[10] = "";
    USART_add_string_to_out_buffer(_float_to_char(x, buff));
    USART_add_char_to_out_buffer(' ');
    USART_add_string_to_out_buffer(_float_to_char(y, buff));
    USART_add_char_to_out_buffer(' ');
    USART_add_string_to_out_buffer(_float_to_char(z, buff));
    USART_add_string_to_out_buffer("\r\n");

    for (int i = -0; i < 34; i++) {
        write_buf();
    }
}

static void init_accelerometer() {
    i2c_write(CTRL_REG1, 0, &zero_reg3);
}

void accelerometer_setup() {
    init_leds();

    i2c_init(PCLK1_HZ);
    configure_gpio();

    USART_setup(BAUDRATE);
    USART_enable();
    init_accelerometer();
}
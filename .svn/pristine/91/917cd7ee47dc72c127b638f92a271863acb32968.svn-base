#include "accelerometer.h"
#include "DMA.h"
#include "i2c_init.h"
#include "leds.h"
#include <gpio.h>
#include <irq.h>
#include <stdint.h>
#include <stm32.h>

#define CTRL_REG1 0x20
#define CTRL_REG3 0x22

#define OUT_X 0x29
#define OUT_Y 0x2B
#define OUT_Z 0x2D

#define SCL_GPIO GPIOB
#define SCL_LINE 8
#define SDA_GPIO GPIOB
#define SDA_LINE 9

#define PCLK1_HZ 16000000

#define X_LED RED
#define Y_LED GREEN
#define Z_LED BLUE

#define LIS35DE_ADDR 0x1C
#define CTRL_REG1_INIT_VALUE 0b01000111
#define CTRL_REG3_INIT_VALUE 0b01000100

#define INT1_GPIO GPIOA
#define INT1_LINE 1
#define INT1_MASK 1u << INT1_LINE

typedef int8_t reg_t;
typedef int8_t reg_val_t;
typedef void (*i2c_write_callback)();
typedef void (*i2c_read_callback)(reg_val_t val);

typedef struct {
    enum i2c_mode_enum { READ, WRITE } mode;
    reg_t reg;
    reg_val_t value;
    union {
        i2c_write_callback write;
        i2c_read_callback read;
    } callback;
} i2c_data_t;

i2c_data_t i2c_data;

static void init_leds() {
    leds_setup();
    Green2LEDon();
}

static void configure_gpio() {
    GPIOafConfigure(SCL_GPIO, SCL_LINE, GPIO_OType_OD, GPIO_Low_Speed, GPIO_PuPd_NOPULL,
                    GPIO_AF_I2C1);
    GPIOafConfigure(SDA_GPIO, SDA_LINE, GPIO_OType_OD, GPIO_Low_Speed, GPIO_PuPd_NOPULL,
                    GPIO_AF_I2C1);
}

void write_buf() {
    while (!(USART2->SR & USART_SR_TXE)) {
    }
    USART_write_from_buffer();
}

static void debug(const char *text) {
    //    return;
    while (*text != '\0') {
        USART_add_char_to_out_buffer(*text);
        write_buf();
        text++;
    }
}

void handle_unmatched_sr1_reg(uint32_t sr1) {
    return;
    for (int i = 0; i < 32; i++) {
        USART_add_char_to_out_buffer(sr1 % 2 + '0');
        write_buf();
        sr1 /= 2;
    }
    USART_add_char_to_out_buffer('\n');
    write_buf();
}

void i2c_write(reg_t reg, reg_val_t value, i2c_write_callback callback);
void i2c_read(reg_t reg, i2c_read_callback callback);

static float float_abs(float f) {
    if (f < 0) {
        return -f;
    }
    return f;
}

static float normalize(float f) {
    return 1 - float_abs(f / 128);
}

void handle_data_ready();

void EXTI1_IRQHandler(void) {
    Green2LEDoff();
    debug("EXTI: ");
    handle_unmatched_sr1_reg(EXTI->PR);
    if (EXTI->PR & EXTI_PR_PR1) {
        EXTI->PR = EXTI_PR_PR1;
        handle_data_ready();
    }
    Green2LEDon();
}

void handle_z(reg_val_t z) {
    leds_change_blue_intensity(normalize(z));
    if ((INT1_GPIO->IDR & INT1_MASK) && !(EXTI->PR & EXTI_PR_PR1)) {
        handle_data_ready();
    }
}

void read_z(reg_val_t y) {
    leds_change_green_intensity(normalize(y));

    i2c_read(OUT_Z, &handle_z);
}

void read_y(reg_val_t x) {
    leds_change_red_intensity(normalize(x));
    i2c_read(OUT_Y, &read_z);
}

void handle_data_ready() {
    i2c_read(OUT_X, &read_y);
}

void set_reg3_config() {
    i2c_write(CTRL_REG3, CTRL_REG3_INIT_VALUE, NULL);
}

void set_reg1_config() {
    GPIOinConfigure(INT1_GPIO, INT1_LINE, GPIO_PuPd_NOPULL, EXTI_Mode_Interrupt,
                    EXTI_Trigger_Rising);
    NVIC_EnableIRQ(EXTI1_IRQn);

    i2c_write(CTRL_REG1, CTRL_REG1_INIT_VALUE, &set_reg3_config);
}

void zero_reg3() {
    i2c_write(CTRL_REG3, 0, &set_reg1_config);
}

void I2C1_EV_IRQHandler_read() {
    enum next { SB, ADDR, BTF, SB2, ADDR2, RXNE };
    static enum next next_state = SB;

    uint16_t sr1 = I2C1->SR1;
    if (next_state == SB && (sr1 & I2C_SR1_SB)) {
        I2C1->DR = LIS35DE_ADDR << 1;
        next_state = ADDR;
    } else if (next_state == ADDR && (sr1 & I2C_SR1_ADDR)) {
        I2C1->SR2;
        I2C1->DR = i2c_data.reg;
        next_state = BTF;
    } else if (next_state == BTF && (sr1 & I2C_SR1_BTF)) {
        I2C1->CR1 |= I2C_CR1_START;
        next_state = SB2;
    } else if (next_state == SB2 && (sr1 & I2C_SR1_SB)) {
        I2C1->DR = LIS35DE_ADDR << 1 | 1;

        I2C1->CR1 &= ~I2C_CR1_ACK;

        next_state = ADDR2;
    } else if (next_state == ADDR2 && (sr1 & I2C_SR1_ADDR)) {
        I2C1->SR2;

        I2C1->CR1 |= I2C_CR1_STOP;
        next_state = RXNE;
    } else if (next_state == RXNE && (sr1 & I2C_SR1_RXNE)) {
        I2C1->CR2 ^= I2C_CR2_ITBUFEN;
        next_state = SB;
        if (i2c_data.callback.read != NULL) {
            i2c_data.callback.read(I2C1->DR);
        }
    } else {
        handle_unmatched_sr1_reg(sr1);
    }
}

void I2C1_EV_IRQHandler_write() {
    enum next { SB, ADDR, TX, BTF };
    static enum next next_state = SB;

    uint16_t sr1 = I2C1->SR1;
    if (next_state == SB && (sr1 & I2C_SR1_SB)) {
        next_state = ADDR;
        I2C1->DR = LIS35DE_ADDR << 1;
    } else if (next_state == ADDR && (sr1 & I2C_SR1_ADDR)) {
        next_state = TX;
        I2C1->SR2;
        I2C1->DR = i2c_data.reg;
    } else if (next_state == TX && (sr1 & I2C_SR1_TXE)) {
        next_state = BTF;
        I2C1->DR = i2c_data.value;
    } else if (next_state == BTF && (sr1 & I2C_SR1_BTF)) {
        next_state = SB;
        I2C1->CR1 |= I2C_CR1_STOP;
        I2C1->CR2 ^= I2C_CR2_ITBUFEN;
        if (i2c_data.callback.write != NULL) {
            i2c_data.callback.write();
        }
    } else {
        handle_unmatched_sr1_reg(sr1);
    }
}

void I2C1_EV_IRQHandler() {
    Green2LEDoff();
    if (i2c_data.mode == READ) {
        I2C1_EV_IRQHandler_read();
    } else {
        I2C1_EV_IRQHandler_write();
    }
    Green2LEDon();
}

void i2c_write(reg_t reg, reg_val_t value, i2c_write_callback callback) {
    i2c_data.mode = WRITE;
    i2c_data.reg = reg;
    i2c_data.value = value;
    i2c_data.callback.write = callback;

    I2C1->CR2 |= I2C_CR2_ITBUFEN;
    I2C1->CR1 |= I2C_CR1_START;
}

void i2c_read(reg_t reg, i2c_read_callback callback) {
    i2c_data.mode = READ;
    i2c_data.reg = reg;
    i2c_data.callback.read = callback;

    I2C1->CR2 |= I2C_CR2_ITBUFEN;
    I2C1->CR1 |= I2C_CR1_START;
}

static void init_accelerometer() {
    NVIC_DisableIRQ(EXTI1_IRQn);
    i2c_write(CTRL_REG1, 0, &zero_reg3);
}

void accelerometer_setup() {
    init_leds();

    i2c_init(PCLK1_HZ);
    configure_gpio();

    USART_setup(BAUDRATE);
    USART_enable();
    init_accelerometer();
}